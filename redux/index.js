{
  colors: [
    {
      "id": "8658c1d0-9eda-4a90-95e1-8001e8eb6036",
      "title": "Ocean Blue",
      "color": "#0070ff",
      "rating": 3,
      "timestamp": "Sat Mar 12 2016 16:12:09 GMT-0800 (PST)"
    },
    {
      "id": "f9005b4e-975e-433d-a646-79df172e1dbb",
      "title": "Tomato",
      "color": "#d10012",
      "rating": 2,
      "timestamp": "Fri Mar 11 2016 12:00:00 GMT-0800 (PST)"
    },
    {
      "id": "58d9caee-6ea6-4d7b-9984-65b145031979",
      "title": "Lawn",
      "color": "#67bf4f",
      "rating": 1,
      "timestamp": "Thu Mar 10 2016 01:11:12 GMT-0800 (PST)"
    },
    {
      "id": "a5685c39-6bdc-4727-9188-6c9a00bf7f95",
      "title": "Party Pink",
      "color": "#ff00f7",
      "rating": 5,
      "timestamp": "Wed Mar 9 2016 03:26:00 GMT-0800 (PST)"
    }
  ]
  sort: "SORTED_BY_DATE"
}

/*
Действие ADD_COLOR
  {
    type: "ADD_COLOR",
    color: "#FFFFFF",
    title: "Bright White",
    rating: 0,
    id: "b5685c39-3bdc-4727-9188-6c9a33df7f52",
    timestamp: "Sat Mar 12 2016 16:12:09 GMT-0800 (PST)"
  }

В Redux модульность достигается за счет функций. Они ис-
пользуются для обновления частей дерева состояния. Эти функции называются
преобразователями

Если для этого приложения потребуется использовать Redux, можно создать несколько
преобразователей, каждый из которых нацелен на конкретные листья или ветви
дерева состояния.

Обратите внимание: преобразователь цвета должен быть объектом и возвращает
объект. Этот преобразователь получает состояние в виде массива и возвраща-
ет массив. Преобразователь сортировки получает строку и возвращает строку.
Каждая функция нацелена на конкретную часть дерева состояния. Возвращаемое
значение и исходное состояние для каждой функции соответствуют своим типам
данных в дереве. Цвета хранятся в массиве. Каждый цвет — объект. Свойство sort
является строкой.


Reducer
  export const color = (state = {}, action) => {
    switch (action.type) {
      case C.ADD_COLOR:
        return {
          id: action.id,
          title: action.title,
          color: action.color,
          timestamp: action.timestamp,
          rating: 0
        }
      case C.RATE_COLOR:
        return (state.id !== action.id) ?
          state :
            {
              ...state,
              rating: action.rating
            }
      default :
        return state
    }
  }

Преобразователи всегда должны что-нибудь возвращать. Если по какой-либо
причине данный преобразователь был вызван с неопознанным действием, то как
вариант по умолчанию ( default ) им будет возвращено текущее состояние.

Подход к состоянию как к неизменяемому объекту
Во всех этих преобразователях к состоянию нужно подходить как к неизме-
няемому объекту. Следует удерживаться от соблазна применять такие вы-
ражения, как state.push({}) или state[index].rating.

В преобразователях не должно быть никаких побочных эффектов
Преобразователи должны быть предсказуемыми. Они используются про-
сто для управления данными состояния. Обратите внимание: в предыдущем
примере метка времени и идентификаторы сгенерированы до отправки дей-
ствия преобразователю. Генерирование случайных данных, вызов функций
API и другие асинхронные процессы должны обрабатываться за пределами
преобразователей. Для них неизменно рекомендуется избегать изменения
состояния и побочных эффектов.

Хранилище
В Redux хранилищем считается то место, где хранятся данные состояния приложе-
ния и обрабатываются все обновления состояния 1 . Хотя модель конструирования
Flux допускает наличие множества хранилищ, каждое из которых нацелено на кон-
кретный набор данных, в Redux имеется только одно.

Хранилище занимается обновлениями состояния, пропуская текущее состояние
и действие через единый преобразователь.

  Если создавать хранилище с помощью преобразователя цветов, то наш объект со-
стояния будет массивом, то есть массивом цветов. Принадлежащий хранилищу ме-
тод getState станет возвращать настоящее состояние приложения.

  import { createStore } from 'redux'
  import { color } from './reducers'
  const store = createStore(color)
  console.log( store.getState() )

Чтобы создать единое дерево преобразователей, похожее на изображенное на рис. 8.6
из предыдущего раздела, нужно составить комбинацию из преобразователей цветов
и сортировки. В Redux для этого имеется специально предназначенная функция
combineReducers , которая сводит все преобразователи в единый. Эти преобразо-
ватели используются для создания вашего дерева состояния. Имена полей соот-
ветствуют именам переданных преобразователей.

import { createStore, combineReducers } from 'redux'
import { colors, sort } from './reducers'
const store = createStore(
  combineReducers({ colors, sort })
)
console.log( store.getState() )



Исходные данные состояния

import { createStore, combineReducers } from 'redux'
import { colors, sort } from './reducers'
const initialState = {...}
const store = createStore(
  combineReducers({ colors, sort }),
  initialState
)


Единственным способом изменения состояния вашего приложения является дис-
петчеризация действий через хранилище. В нем имеется метод dispatch , готовый
получить действия в виде аргумента. При диспетчеризации с помощью хранилища
действие проводится через преобразователи и состояние обновляется:
store.dispatch({
  type: "RATE_COLOR",
  id: "2222e1p5-3abl-0p523-30e4-8001l8yf2222",
  rating: 5
})

Подписка на хранилища
Хранилища позволяют осуществлять подписку функций-обработчиков, вызыва­
емых после каждого завершения хранилищем диспетчеризации действия
store.subscribe(() =>
  console.log('color count:', store.getState().colors.length)
)


Принадлежащий хранилищу метод subscribe возвращает функцию, которую поз-
же можно использовать для прекращения подписки слушателя:

const logState = () => console.log('next state', store.getState())
const unsubscribeLogger = store.subscribe(logState)
  // Вызвать по готовности к прекращению подписки слушателя
unsubscribeLogger()


Создатели действий являются функциями, которые создают и возвращают эти литералы Действия
export const removeColor = id =>
  ({
    type: C.REMOVE_COLOR,
    id
  })
export const rateColor = (id, rating) =>
  ({
    type: C.RATE_COLOR,
    id,
    rating
  })

  Создатели упрощают задачу диспетчеризации действий; нам остается лишь вы-
звать функцию и отправить ей необходимые данные. Создатели способны абстра-
гировать от подробностей того, как создается действие, что может существенно
упростить процесс создания действия. Например, если создается действие под
названием sortBy , то создатель может принять решение о соответствующих мерах
по его реализации:


Создатели действий хороши тем, что предоставляют место для инкапсуляции
всей логики, необходимой для успешного создания действия. Создатель действий
addColor берет на себя все связанное с добавлением новых цветов, включая предо-
ставление уникальных идентификаторов и установку на действие метки времени.
Все перечисленное находится в одном месте, что существенно упрощает отладку
приложения.

В создатель действий нужно помещать всю логику обмена данными с серверными
API. Используя создатель, можно задействовать логику асинхронного обмена
данными,­ такую как запрос данных или вызов функций API.

compose
Redux также поставляется с функцией compose, которой можно воспользоваться
для составления нескольких функций в одну. Это похоже на составление комби-
нации функций в главе 3, но приводит к более надежному результату. Кроме того,
функции составляются не слева направо, а наоборот.
Если нужен просто список цветов с запятыми в качестве разделителей, то можно
воспользоваться следующей весьма необычной по виду строкой кода:


В Store - хранилище очень маленький API, состоящий всего из четырех методов:

Отправить действие в store 
  store.dispatch(action) 

Добавляет слушателя
  store.subscribe(listener) 

Возвращает текущее состояние вашего приложения 
  store.getState() 

Заменяет редьюсер, который в настоящее время используется хранилищем 
  replaceReducer(nextReducer)  
*/